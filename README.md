# Polygon Optimization

Περιεχόμενα <br>
[Περιγραφή](#a-περιγραφή)<br>
[Δομή Κώδικα](#β-δομή-κώδικα)<br>
[Μεταγλώττιση](#γ-μεταγλώττιση)<br>
[Οδηγίες Χρήσης](#δ-οδηγίες-χρήσης)<br>
[Φοιτήτες](#ε-φοιτητές)<br>
[Local Search](#local-search)<br>
[Simulated Annealing](#simulated-annealing)<br>
[Ant Colony](#ant-colony)<br>

## A. Περιγραφή
<p>
Το πρόγραμμα βελτιστοποιεί το εμβαδόν ενός απλού πολυγώνου που διέρχεται από όλα τα σημεία ενός δοσμένου σημειοσυνόλου. Αξιοποιεί τρεις διαφορετικούς αλγορίθμους για την βελτιστοποίηση του εμβαδού. Ανάλογα με τον αλγόριθμο βελτιστοποίησης, εκμεταλεύεται και τους αλγορίθμους της 1ης Εργασίας. Η βελτιστοποίηση μπορεί να είναι είτε μεγιστοποίηση είτε ελαχιστοποίηση, με βάση πάντα το αντίστοιχο όρισμα στην είσοδο.
</p>
<br>

## Β. Δομή Κώδικα
<ul>
<li>
<b>main.cpp</b><br>
Στο αρχείο αυτό αξιοποιούνται όλα τα άλλα και έχει γραφεί η main συνάρτηση. Εδώ γίνεται ο έλεγχος των ορισμάτων, το διάβασμα τις εισόδου, η διαχείριση της παραμετρικής λειτουργίας του προγράμματος και η παραγωγή του/των αρχείου/αρχείων εξόδου. <br>
</li>
<li>
<b>shared.h</b><br>
    Τα κοινά header αρχεία που γίνονται include από τα αρχεία υλοποίησης των αλγορίθμων, κοινός ορισμός typedef για ομοιότητα στον κώδικα και ορισμός structs και enums για την να είναι πιο ευανάγνωστος ο κώδικας στην main συνάρτηση.
</li>
<li>
<b>PolygonGenerator.h</b><br>
    Ορισμός abstract κλάσης που περιγράφει την γενική λειτουργία ενός αλγόριθμου που παίρνει σημειοσύνολο ως είσοδο και παράγει ένα απλό πολύγωνο που διέρχεται από όλα τα σημεία. Κάθε κλάση που υλοποιεί έναν αλγόριθμο, είναι υποκλάση αυτής. 
</li>
<li>
<b>PolygonOptimizer.h</b><br>
    Ορισμός abstract κλάσης που περιγράφει την γενική λειτουργία ενός αλγόριθμου που παίρνει ένα πολύγωνο  που διέρχεται από όλα τα σημεία ως είσοδο και το βελτιστοποιεί με βάση την είσοδο (-min ή -max), επιστρέφοντας το βέλτιστο πολύγωνο. Κάθε κλάση που υλοποιεί έναν αλγόριθμο βελτιστοποίησης, είναι υποκλάση αυτής. 
</li>
<li>
<b>incr.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αυξητικό αλγόριθμο (incremental).
</li>
<li>
<b>incr.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αυξητικό αλγόριθμο για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>ConvexHullAlgo.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο convex hull.
</li>
<li>
<b>ConvexHullAlgo.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο convex hull για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>onion.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο onion και συναρτήσεων της.
</li>
<li>
<b>onion.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο onion για την παραγωγή του ζητούμενου πολυγώνου. Από την 1η εργασία
</li>
<li>
<b>local.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο βελτιστοποίησης local search και συναρτήσεων της.
</li>
<li>
<b>local.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο βελτιστοποίησης local search και συναρτήσεων της.
</li>
<li>
<b>SimulatedAnnealing.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο simulated annealing και συναρτήσεων της.
</li>
<li>
<b>SimulatedAnnealing.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο simulated annealing και συναρτήσεων της.
</li>
<li>
<b>ant.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο ant colony και συναρτήσεων της.
</li>
<li>
<b>ant.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο ant colony και συναρτήσεων της.
</li>
<li>
<b>Pick.h</b><br>
    Ορισμός της συνάρτησης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>Pick.cpp</b><br>
    Υλοποίηση της συνάρτης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>pythonQgisScript.py</b><br>
    Python script που αξιοποεί τα WKT αρχεία που παράγει το πρόγραμμα (αν δώσουμε το flag -show_shapes) για το λογισμικό QGIS. Για να αξιοποιηθεί χρειάζεται να έχουμε βάλει στο QGIS την επέκταση QuickWKT και να αλλάξουμε την τιμή της μεταβλητής exeDir στο full path του καταλόγου του εκτελέσιμου.
</li>
</ul>
<br>

## Γ. Μεταγλώττιση
Στον κατάλογο που βρίσκονται τα πηγαία αρχεία αρχικά τρέχουμε: <br>
<code>
    cgal_create_CMakeLists -s optimal_polygon <br>
</code>
<br>
Έπειτα, τρέχουμε:<br>
<code> 
    cmake -DCGAL_DIR = path-to-cgal-dir .<br>
</code>
<br>
Τέλος, τρέχουμε: <br>
<code>
    make <br>
</code>
<br>
όπου path-to-cgal-dir το path στον κατάλογο CGAL
<br>

## Δ. Οδηγίες Χρήσης
<code>
    ./optimal_polygon -i "input-file" -o "output-file" -algorithm "algorithm" [FLAGS] -gen "generate" <br>
</code>
    όπου: <br>
    <ul>
    <li>"input-file" το αρχείο εισόδου με τα σημεία υπό την μορφή που περιγράφεται στην εκφώνηση</li>
    <li>"output-file" το αρχείο εξόδου που θέλουμε να παραχτεί. Περιέχει τα αποτελέσματα υπό την μορφή που περιγράφονται στην εκφώνηση</li>
    <li>"algorithm" μία από τις τιμές: local_search, simulated_annealing, ant_colony για τον αντίστοιχο αλγόριθμο βελτιστοποίησης</li>
    <li>[FLAGS]:<br>
        <code> -max </code> Αν θέλουμε να έχουμε μεγιστοποίση του εμβαδού. Δεν μπορεί να συνυπάρχει με το <code> -min </code><br>
        <code> -min </code> Αν θέλουμε να έχουμε ελαχιστοποίηση του εμβαδού. Δεν μπορεί να συνυπάρχει με το <code> -max </code><br>
        <code>-L</code> Η παράμετρος L, με διαφορετική λειτουργικότητα ανά αλγόριθμο βελτιστοποίσης <br>
        Για τον κάθε αλγόριθμο βελτιστοποίησης: <br>
        <ul>
            <li>Για τον local_search:<br>
                <code>-threshold</code>. Ο λόγος του πολυγώνου για βελτίωση προς το convexHullArea.Όσο πιο κοντά βρίσκεται ο αριθμός αυτός στο 1
                τόσο περισσότερο πλησιάζει το πολύγωνο στο μέγιστο δυνατό.Αντίστοιχα, όσο πιο κοντά βρίσκεται ο αριθμός αυτός στο 0
                τόσο περισσότερο πλησιάζει το πολύγωνο στο ελάχιστο δυνατό.Έτσι, τιμές κοντά στο 1 (πχ. 0.88) προτιμούνται για 
                καλές μεγιστοποιήσεις και τιμές κοντα στο 0 (πχ 0.16) για καλές ελαχιστοποιήσεις.<br>
                Δυνατές τιμές:<br>
                Όλοι οι οι πραγματικοί αριθμοί στον διάστημα (0,1].<br>
            </li>
            <li>Για τον simulated_annealing:<br>
                <code>-annealing</code>. Δυνατές τιμές:<br>
                local<br>
                global<br>
                subdivision <br>
            </li>
            <li>Για τον ant_colony:<br>
                <code>-alpha</code>. Δυνατές τιμές:<br>
                θετικός δεκαδικός αριθμός<br>
                <code>-beta</code>. Δυνατές τιμές:<br>
                θετικός δεκαδικός αριθμός<br>
                <code>-ro</code>. Δυνατές τιμές:<br>
                θετικός αριθμός από 0 μέχρι 1. Παίρνει γενικά χαμηλές τιμές (πχ. 0.05)<br>
                <code>-elitism</code>. Δυνατές τιμές:<br>
                0 ή 1.
            </li>
        </ul>
    </li>
    <li>"generate" μία από τις τιμές: incremental, convex_hull, onion για τον αντίστοιχο αλγόριθμο υπολογισμού της αρχικής πολυγωνικής γραμμής</li>
    </ul>
    Παράδειγματα εκτέλεσης: <br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000015.instance -o result.txt -algorithm ant_colony -L 5 -max -alpha 1.0 -beta 1.0 -ro 0.05 -elitism 0 -gen onion</code><br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000060.instance -o result.txt -algorithm local_search -L 10 -min -threshold 0.16 -gen convex_hull</code><br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000020.instance -o result.txt -algorithm simulated_annealing -L 10 -min -annealing local -gen convex_hull</code><br>
    

## Ε. Φοιτητές

Λουκάς Μαστορόπουλος &nbsp; 1115 2017 00078 <br>
Νικόλαος Χαρίσης &nbsp; 1115 2017 00187 <br>
Θάνος Βάιος   &nbsp;  &nbsp;  1115 2018 00016 <br>

## Local Search
Δομές:<br>
<ul>
<li>  <b> Polygon_2 </b> που αντιπροσωπεύει το τελικό βέλτιστο πολύγωνο που επιστρέφεται. Από την CGAL</li>
<li>
 <b> Point_2 </b> που αντιπροσωπεύει τα σημεία του χώρου και τις κορυφές των πολυγώνων. Από την CGAL
</li>
<li>
<b> Segment_2 </b> για την αναπαράσταση των ακμών ανάμεσα σε διάφορα σημεία. Από την CGAL
</li>
<li>
<b> Vector </b> που χρησιμοποιείται για την αποθήκευση των σημείων και πρακτικά της πολυγωνικής αλυσίδας V. Από την STL
</li>
<li>
<b> List </b> που χρησιμοποιείται για την αποθήκευση των αλλαγών. Από την STL
</li>
<li>
Struct <b> changePair </b> που χρησιμοποιείται για την αναπαράσταση του ζεύγους (e,V), όπου e είναι η ακμή που πρέπει να "σπάσει" και V η πολυγωνική αλυσίδα
</li>
<li>
Struct <b> areaChange </b> που χρησιμοποιείται για να αναπαραστίσει το tuple (change,area), όπου change είναι η αλλαγή που μπορεί να εφαρμοστεί και area το εμβαδόν που προκύπτει από αυτή την αλλαγή.
</li>
</ul>

Κύρια Λειτουργία:<br>
<ul>
Το local.cpp υλοποιεί κατά βάση 2 πράγματα. Τον constructor της κλασης LocalAlgo και την συνάρτηση optimalPolygon.
<li> <code> LocalAlgo </code>: <br> <br>
<p> Ο Constructor αρχικά καλεί τον constructor της υπερκλασης PolygonOptimizer με όρισμα το poly. Στη συνέχεια αρχικοποιεί τα πεδία threshold, conxvexHullArea, length  και type με βάση ό,τι έχει δωθεί
</p>
</li>
<li><code> optimizalPolygon</code>: <br> <br>
<p> Η συνάρτηση που υλοποιεί την βελτιστοποίηση ενός πολυγώνου. Βελτιστοποιεί το πολύγωνο που βρίσκεται στο πεδίο poly της κλάσσης LocalAlgo, το οποίο το έχει κληρονομήθει από την υπερκλάσση PolygonOptimizer, ακολουθώντας τον αλγόριθμο που παρουσιάζεται στο αντίστοιχο paper ,που υπάρχει στο eclass, με μερικές μικρές τροποποιήσεις.
</p>
<p>
Αρχικά, γίνεται έλεγχος για το μέγεθος L της αλυσίδας σημείων V. Η τιμή του L πρέπει να ειναι ακέραια, απο 1 μέχρι και 10 και για τα μικρά σημειοσύνολα (πχ αυτά με 10 σημεία) να είναι μικρότερη από το πλήθος των κορυφών του πολυγώνου προς βελτιστοποίηση. Σε περίπτωση που αυτός ο έλεγχος αποτύχει, επιστρέφεται το αρχικό μη βελτιστοποιήμενο πολύγωνο.
</p>
<p> 
Έπειτα, ορίζει το αρχικό score που παίρνουμε από το αρχικό πολύγωνο. Εδώ, πρέπει να σημειώσουμε πως ακολουθούμε την λογική του paper και ορίζουμε ως score (και αντίστοιχα και ως threshold) το λόγο του εμβαδού του πολυγώνου που εξετάζουμε/βελτιστοποιούμε προς το εμβαδό του ΚΠ, το οποίο και είναι το καλύτερο άνω φράγμα που μπορούμε να πάρουμε για το εμβαδό του πολυγώνου. Όσο το score τείνει προς το 1, τόσο περισσότερο "μοιάζει" το πολύγωνο με το ΚΠ και άρα τόσο μεγαλώνει. Όσο το score τείνει προς το 0, τόσο περισσότερο "διαφέρει" το πολύγωνο με ΚΠ και άρα τόσο μικραίνει. Γενικά, όσο πιο κοντά στο 1 είναι η τιμή που θα δώσουμε στο threshold, τόσο καλύτερη μεγιστοποίηση θα πάρουμε (μια τιμη αρκετά καλή είναι το 0.88). Όσο πιο κοντά στο 0 είναι η τιμή που θα δώσουμε στο threshold, τόσο καλύτερη ελαχιστοποίηση θα πάρουμε (μια τιμη αρκετά καλή είναι το 0.16).Επίσης, ορίζουμε και την λίστα με τις πιθανές αλλαγές. Η λίστα αυτή θα μπορούσε να οριστεί και μέσα στο while loop, πριν διατρέξουμε τις ακμές του πολυγώνου. Το πρόγραμμα θα ήταν ελαφρώς πιο γρηγόρο αλλά η βελτιστοποίηση, σε σχέση με την υλοποίηση που προτιμήθηκε θα ήταν χειρότερη. Για αυτό, αποφασίστηκε να θυσιαστεί χρόνος για να έχουμε καλύτερα αποτελέσματα.
</p>
<p>
Μέσα στο while loop, υλοποιείται ο αλγόριθμος του paper. Αν υπάρχουν μερικά σημεία που είναι άξια αναφοράς, αυτά είναι το διάφορα τρικάκια προκειμένου να αποφύγουμε ελέγχους και εφαρμογές αλλαγών που είναι περιττές. Αρχικά, μια αλλάγη εξετάζεται μονάχα αν η αλυσίδα V δεν έχει τμήματά της μέσα στην ακμή e που εξετάζεται και αν η V δεν έχει τμήματά της και στις γειτονικές της e (e+1,e-1). Επίσης, κάθε αλλαγή που χρησιμοποιείται, μαρκάρεται αλλάζωντας το area της (με -1 αν πρόκειται για μεγιστοποίηση, με convexHullArea αν πρόκειται για ελαχιστοποίηση). Το σκεπτικό είναι ότι, έπειτα από το σορτάρισμα της λίστας (αφού την διατρέξουμε), οι μαρκαρισμένες αλλάγες θα είναι όλες μαζί στην σειρά. Έτσι, μόλις πετύχουμε την πρώτη, μπορούμε απλά να σταματήσουμε να διατρέχουμε την λίστα των αλλαγών, να σκιπαρόυμε τις "άχρηστες" αλλαγές και να συνεχίσουμε στην επόμενη επανάληψη της διαδικασίας βελτίωσης. Τέλος, σε κάθε επανάληψη , ελέχγουμε αν η λιστά αλλαγών είναι κενή (δηλαδή αν όντως βρήκαμε "νόμιμες" και ωφέλιμες αλλαγές) και αν οι αλλαγές που έχουμε στη διάθεση μας είναι όντως "νόμιμες" και "ωφέλιμες" (αυτό γίνεται με τη μεταβλητή improved). Αν καμία από τις παραπάνω συνθήκες δεν ισχύει, τότε θέτουμε το score ίσο με το threshold, έτσι ώστε να βγούμε απο το while loop. 
</p>
<p>
Ειδική μνεία αξίζει να κάνουμε στην λίστα με τις αλλάγες (possibleChanges) και στο τι ακριβώς περιέχει. Συγκεκριμένα, περιέχει structs του τύπου areaChange. Κάθε struct αυτής της μορφής αποτελείται από ένα πεδίο struct changePair που αντιπροσωπεύει την αλλαγή (e,V) και ένα πεδίο area που αντιστοιχεί στο εμβαδό που θα επιφέρει η εφαρμογή της αλλαγής αυτή στο πολύγωνο. Η λίστα possibleChanges είναι σορταρισμένη έτσι ώστε οι καλύτερς αλλαγές, με βάση την βελτιστοποίηση που θέλουμε, να είναι πρώτες.
</p>
</li>
</ul>

Λοιπές Συναρτήσεις:<br>
<ul>
<p>Πέρα από τις βασικές συναρτήσεις που περιγράφηκαν πιο πάνω στο local.cpp είναι ορισμένες και κάποιοες βοηθητικές συναρτήσεις.
</p>
<li>
<code> checkThreshold </code> <br>
Η συνάρτηση που ελέγχει αν έχουμε φτάσει ή ξεπεράσει το ζητούμε threshold με βάση τον τύπο της βελτιστοποίησης που ζητείται
</li>
<li>
<code> areaImproves </code> <br>
Η συνάρτηση που ελέγχει αν έχουμε βελτιώσει το εμβαδό με βάση τον τύπο της βελτιστοποίησης που ζητείται
</li>
<li>
<code> findVertexInPoly </code> <br>
Η συνάρτηση που ελέγχει αν μια κορυφή ανήκει στο δοσμένο πολύγωνο
</li>
<li>
<code> findEdgeInPoly </code> <br>
Η συνάρτηση που ελέγχει αν μια ακμή ανήκει στο δοσμένο πολύγωνο
</li>
<li>
<code> compareAlterMin </code> <br>
Η συνάρτηση που συγκρίνει 2 areaChange, για ελαχιστοποίηση
</li>
<li>
<code> compareAlterMax </code> <br>
Η συνάρτηση που συγκρίνει 2 areaChange, για μεγιστοποίηση
</li>
<li>
<code> chainInEdge </code> <br>
Η συνάρτηση που ελέγχει αν έστω και ένα σημείο της αλυσίδας V ανήκει στη δοσμένη ακμή
</li>
<li>
<code> applyChanges </code> <br>
Η συνάρτηση που εφορμόζει τις δωθείσες αλλαγές στο δοσμένο πολύγωνο
</li>
<li>
<code> getVertexIt </code> <br>
Επιστρέφει τον Vertex_Iterator που αντιστοιχεί στην κορυφή. Από το onion.cpp
</li>
<li>
<code> pointInEdge </code> <br>
Η συνάρτηση που ελέγχει αν το δοσμένο σημείο είναι μια από τις κορυφές της ακμής
</li>
<li>
<code> getNextEdge </code> <br>
Συνάρτηση που βρίσκει την επόμενη ακμή μετά το eit και κάνει το eit να δείχνει εκει
</li>
<li>
<code> getPreviousEdge </code> <br>
Συνάρτηση που βρίσκει την προηγούμε ακμή πριν το eit και κάνει το eit να δείχνει εκει
</li>
<li>
<code> getNextIter </code> <br>
Συνάρτηση που βρίσκει την επόμενη κορυφή μετά το veit και κάνει το veit να δείχνει εκει
</li>
<li>
<code> getPreviousIter </code> <br>
Συνάρτηση που βρίσκει την προηγούμε κορυφή πριν το veit και κάνει το veit να δείχνει εκει
</li>
</ul>

Σημειώσεις / Σχεδιαστικές Επιλογές:<br>
<ul>
<p> Κατά την υλοποιήση του αλγορίθμου εμφανίστηκε η ανάγκη για την λήψη μερικών σχεδιαστικών επιλογών/αποφάσεων. Αυτές είναι:<br>
</p>

</ul>

Αποτελέσματα Εκτελέσεων και Σχολιασμός:<br>
<ul>
Τα αποτελέσματα κάποιων ενδεικτικών εκτελέσεων υπάρχουν αναλυτικότερα στον φάκελο docs/ στο αντίστοιχο pdf.
Ένας πρόχειρος σχολιασμός αυτών είναι ο εξής:

<br>
</ul>
<br>

## Simulated Annealing

<br>

## Ant Colony

<br>
