# Polygon Optimization

Περιεχόμενα <br>
[Περιγραφή](#a-περιγραφή)<br>
[Δομή Κώδικα](#β-δομή-κώδικα)<br>
[Μεταγλώττιση](#γ-μεταγλώττιση)<br>
[Οδηγίες Χρήσης](#δ-οδηγίες-χρήσης)<br>
[Φοιτήτες](#ε-φοιτητές)<br>
[Local Search](#local-search)<br>
[Simulated Annealing](#simulated-annealing)<br>
[Ant Colony](#ant-colony)<br>

## A. Περιγραφή
<p>
Το πρόγραμμα βελτιστοποιεί το εμβαδόν ενός απλού πολυγώνου που διέρχεται από όλα τα σημεία ενός δοσμένου σημειοσυνόλου. Αξιοποιεί τρεις διαφορετικούς αλγορίθμους για την βελτιστοποίηση του εμβαδού. Ανάλογα με τον αλγόριθμο βελτιστοποίησης, εκμεταλεύεται και τους αλγορίθμους της 1ης Εργασίας. Η βελτιστοποίηση μπορεί να είναι είτε μεγιστοποίηση είτε ελαχιστοποίηση, με βάση πάντα το αντίστοιχο όρισμα στην είσοδο.
</p>
<br>

## Β. Δομή Κώδικα
<ul>
<li>
<b>main.cpp</b><br>
Στο αρχείο αυτό αξιοποιούνται όλα τα άλλα και έχει γραφεί η main συνάρτηση. Εδώ γίνεται ο έλεγχος των ορισμάτων, το διάβασμα τις εισόδου, η διαχείριση της παραμετρικής λειτουργίας του προγράμματος και η παραγωγή του/των αρχείου/αρχείων εξόδου. <br>
</li>
<li>
<b>shared.h</b><br>
    Τα κοινά header αρχεία που γίνονται include από τα αρχεία υλοποίησης των αλγορίθμων, κοινός ορισμός typedef για ομοιότητα στον κώδικα και ορισμός structs και enums για την να είναι πιο ευανάγνωστος ο κώδικας στην main συνάρτηση.
</li>
<li>
<b>PolygonGenerator.h</b><br>
    Ορισμός abstract κλάσης που περιγράφει την γενική λειτουργία ενός αλγόριθμου που παίρνει σημειοσύνολο ως είσοδο και παράγει ένα απλό πολύγωνο που διέρχεται από όλα τα σημεία. Κάθε κλάση που υλοποιεί έναν αλγόριθμο, είναι υποκλάση αυτής. 
</li>
<li>
<b>PolygonOptimizer.h</b><br>
    Ορισμός abstract κλάσης που περιγράφει την γενική λειτουργία ενός αλγόριθμου που παίρνει ένα πολύγωνο  που διέρχεται από όλα τα σημεία ως είσοδο και το βελτιστοποιεί με βάση την είσοδο (-min ή -max), επιστρέφοντας το βέλτιστο πολύγωνο. Κάθε κλάση που υλοποιεί έναν αλγόριθμο βελτιστοποίησης, είναι υποκλάση αυτής. 
</li>
<li>
<b>incr.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αυξητικό αλγόριθμο (incremental).
</li>
<li>
<b>incr.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αυξητικό αλγόριθμο για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>ConvexHullAlgo.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο convex hull.
</li>
<li>
<b>ConvexHullAlgo.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο convex hull για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>onion.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο onion και συναρτήσεων της.
</li>
<li>
<b>onion.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο onion για την παραγωγή του ζητούμενου πολυγώνου. Από την 1η εργασία
</li>
<li>
<b>local.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο βελτιστοποίησης local search και συναρτήσεων της.
</li>
<li>
<b>local.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο βελτιστοποίησης local search και συναρτήσεων της.
</li>
<li>
<b>SimulatedAnnealing.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο simulated annealing και συναρτήσεων της.
</li>
<li>
<b>SimulatedAnnealing.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο simulated annealing και συναρτήσεων της.
</li>
<li>
<b>ant.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο ant colony και συναρτήσεων της.
</li>
<li>
<b>ant.cpp</b><br>
    Υλοποίηση κλάσης που υλοποιεί τον αλγόριθμο ant colony και συναρτήσεων της.
</li>
<li>
<b>Pick.h</b><br>
    Ορισμός της συνάρτησης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>Pick.cpp</b><br>
    Υλοποίηση της συνάρτης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>pythonQgisScript.py</b><br>
    Python script που αξιοποεί τα WKT αρχεία που παράγει το πρόγραμμα (αν δώσουμε το flag -show_shapes) για το λογισμικό QGIS. Για να αξιοποιηθεί χρειάζεται να έχουμε βάλει στο QGIS την επέκταση QuickWKT και να αλλάξουμε την τιμή της μεταβλητής exeDir στο full path του καταλόγου του εκτελέσιμου.
</li>
</ul>
<br>

## Γ. Μεταγλώττιση
Στον κατάλογο που βρίσκονται τα πηγαία αρχεία αρχικά τρέχουμε: <br>
<code>
    cgal_create_CMakeLists -s optimal_polygon <br>
</code>
<br>
Έπειτα, τρέχουμε:<br>
<code> 
    cmake -DCGAL_DIR = path-to-cgal-dir .<br>
</code>
<br>
Τέλος, τρέχουμε: <br>
<code>
    make <br>
</code>
<br>
όπου path-to-cgal-dir το path στον κατάλογο CGAL
<br>

## Δ. Οδηγίες Χρήσης
<code>
    ./optimal_polygon -i "input-file" -o "output-file" -algorithm "algorithm" [FLAGS] -gen "generate" <br>
</code>
    όπου: <br>
    <ul>
    <li>"input-file" το αρχείο εισόδου με τα σημεία υπό την μορφή που περιγράφεται στην εκφώνηση</li>
    <li>"output-file" το αρχείο εξόδου που θέλουμε να παραχτεί. Περιέχει τα αποτελέσματα υπό την μορφή που περιγράφονται στην εκφώνηση</li>
    <li>"algorithm" μία από τις τιμές: local_search, simulated_annealing, ant_colony για τον αντίστοιχο αλγόριθμο βελτιστοποίησης</li>
    <li>[FLAGS]:<br>
        <code> -max </code> Αν θέλουμε να έχουμε μεγιστοποίση του εμβαδού. Δεν μπορεί να συνυπάρχει με το <code> -min </code><br>
        <code> -min </code> Αν θέλουμε να έχουμε ελαχιστοποίηση του εμβαδού. Δεν μπορεί να συνυπάρχει με το <code> -max </code><br>
        <code>-L</code> Η παράμετρος L, με διαφορετική λειτουργικότητα ανά αλγόριθμο βελτιστοποίσης <br>
        Για τον κάθε αλγόριθμο βελτιστοποίησης: <br>
        <ul>
            <li>Για τον local_search:<br>
                <code>-threshold</code>. Ο λόγος του πολυγώνου για βελτίωση προς το convexHullArea.Όσο πιο κοντά βρίσκεται ο αριθμός αυτός στο 1
                τόσο περισσότερο πλησιάζει το πολύγωνο στο μέγιστο δυνατό.Αντίστοιχα, όσο πιο κοντά βρίσκεται ο αριθμός αυτός στο 0
                τόσο περισσότερο πλησιάζει το πολύγωνο στο ελάχιστο δυνατό.Έτσι, τιμές κοντά στο 1 (πχ. 0.88) προτιμούνται για 
                καλές μεγιστοποιήσεις και τιμές κοντα στο 0 (πχ 0.16) για καλές ελαχιστοποιήσεις.<br>
                Δυνατές τιμές:<br>
                Όλοι οι οι πραγματικοί αριθμοί στον διάστημα (0,1].<br>
            </li>
            <li>Για τον simulated_annealing:<br>
                <code>-annealing</code>. Δυνατές τιμές:<br>
                local<br>
                global<br>
                subdivision <br>
            </li>
            <li>Για τον ant_colony:<br>
                <code>-alpha</code>. Δυνατές τιμές:<br>
                θετικός δεκαδικός αριθμός<br>
                <code>-beta</code>. Δυνατές τιμές:<br>
                θετικός δεκαδικός αριθμός<br>
                <code>-ro</code>. Δυνατές τιμές:<br>
                θετικός αριθμός από 0 μέχρι 1. Παίρνει γενικά χαμηλές τιμές (πχ. 0.05)<br>
                <code>-elitism</code>. Δυνατές τιμές:<br>
                0 ή 1.
            </li>
        </ul>
    </li>
    <li>"generate" μία από τις τιμές: incremental, convex_hull, onion για τον αντίστοιχο αλγόριθμο υπολογισμού της αρχικής πολυγωνικής γραμμής</li>
    </ul>
    Παράδειγματα εκτέλεσης: <br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000015.instance -o result.txt -algorithm ant_colony -L 5 -max -alpha 1.0 -beta 1.0 -ro 0.05 -elitism 0 -gen onion</code><br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000020.instance -o result.txt -algorithm local_search -L 10 -min -threshold 0.16 -gen convex_hull</code><br>
    <code>./optimal_polygon -i ./instances/data/images/euro-night-0000020.instance -o result.txt -algorithm simulated_annealing -L 10 -min -annealing local -gen convex_hull</code><br>
    

## Ε. Φοιτητές

Λουκάς Μαστορόπουλος &nbsp; 1115 2017 00078 <br>
Νικόλαος Χαρίσης &nbsp; 1115 2017 00187 <br>
Θάνος Βάιος   &nbsp;  &nbsp;  1115 2018 00016 <br>

## Local Search
<b>Δομές:</b><br>
<ul>
<li>  <b> Polygon_2 </b> που αντιπροσωπεύει το τελικό βέλτιστο πολύγωνο που επιστρέφεται. Από την CGAL</li>
<li>
 <b> Point_2 </b> που αντιπροσωπεύει τα σημεία του χώρου και τις κορυφές των πολυγώνων. Από την CGAL
</li>
<li>
<b> Segment_2 </b> για την αναπαράσταση των ακμών ανάμεσα σε διάφορα σημεία. Από την CGAL
</li>
<li>
<b> Vector </b> που χρησιμοποιείται για την αποθήκευση των σημείων και πρακτικά της πολυγωνικής αλυσίδας V. Από την STL
</li>
<li>
<b> List </b> που χρησιμοποιείται για την αποθήκευση των αλλαγών. Από την STL
</li>
<li>
Struct <b> changePair </b> που χρησιμοποιείται για την αναπαράσταση του ζεύγους (e,V), όπου e είναι η ακμή που πρέπει να "σπάσει" και V η πολυγωνική αλυσίδα
</li>
<li>
Struct <b> areaChange </b> που χρησιμοποιείται για να αναπαραστίσει το tuple (change,area), όπου change είναι η αλλαγή που μπορεί να εφαρμοστεί και area το εμβαδόν που προκύπτει από αυτή την αλλαγή.
</li>
</ul>

<b>Κύρια Λειτουργία:</b><br>
<ul>
Το local.cpp υλοποιεί κατά βάση 2 πράγματα. Τον constructor της κλασης LocalAlgo και την συνάρτηση optimalPolygon.
<li> <code> LocalAlgo </code>: <br> <br>
<p> Ο Constructor αρχικά καλεί τον constructor της υπερκλασης PolygonOptimizer με όρισμα το poly. Στη συνέχεια αρχικοποιεί τα πεδία threshold, conxvexHullArea, length  και type με βάση ό,τι έχει δωθεί
</p>
</li>
<li><code> optimizalPolygon</code>: <br> <br>
<p> Η συνάρτηση που υλοποιεί την βελτιστοποίηση ενός πολυγώνου. Βελτιστοποιεί το πολύγωνο που βρίσκεται στο πεδίο poly της κλάσσης LocalAlgo, το οποίο το έχει κληρονομήθει από την υπερκλάσση PolygonOptimizer, ακολουθώντας τον αλγόριθμο που παρουσιάζεται στο αντίστοιχο paper ,που υπάρχει στο eclass, με μερικές μικρές τροποποιήσεις.
</p>
<p>
Αρχικά, γίνεται έλεγχος για το μέγεθος L της αλυσίδας σημείων V. Η τιμή του L πρέπει να ειναι ακέραια, απο 1 μέχρι και 10 και για τα μικρά σημειοσύνολα (πχ αυτά με 10 σημεία) να είναι μικρότερη από το πλήθος των κορυφών του πολυγώνου προς βελτιστοποίηση. Σε περίπτωση που αυτός ο έλεγχος αποτύχει, επιστρέφεται το αρχικό μη βελτιστοποιήμενο πολύγωνο.
</p>
<p> 
Έπειτα, ορίζει το αρχικό score που παίρνουμε από το αρχικό πολύγωνο. Εδώ, πρέπει να σημειώσουμε πως ακολουθούμε την λογική του paper και ορίζουμε ως score (και αντίστοιχα και ως threshold) το λόγο του εμβαδού του πολυγώνου που εξετάζουμε/βελτιστοποιούμε προς το εμβαδό του ΚΠ, το οποίο και είναι το καλύτερο άνω φράγμα που μπορούμε να πάρουμε για το εμβαδό του πολυγώνου. Όσο το score τείνει προς το 1, τόσο περισσότερο "μοιάζει" το πολύγωνο με το ΚΠ και άρα τόσο μεγαλώνει. Όσο το score τείνει προς το 0, τόσο περισσότερο "διαφέρει" το πολύγωνο με ΚΠ και άρα τόσο μικραίνει. Γενικά, όσο πιο κοντά στο 1 είναι η τιμή που θα δώσουμε στο threshold, τόσο καλύτερη μεγιστοποίηση θα πάρουμε (μια τιμη αρκετά καλή είναι το 0.88). Όσο πιο κοντά στο 0 είναι η τιμή που θα δώσουμε στο threshold, τόσο καλύτερη ελαχιστοποίηση θα πάρουμε (μια τιμη αρκετά καλή είναι το 0.16).Επίσης, ορίζουμε και την λίστα με τις πιθανές αλλαγές. Η λίστα αυτή θα μπορούσε να οριστεί και μέσα στο while loop, πριν διατρέξουμε τις ακμές του πολυγώνου. Το πρόγραμμα θα ήταν ελαφρώς πιο γρηγόρο αλλά η βελτιστοποίηση, σε σχέση με την υλοποίηση που προτιμήθηκε θα ήταν χειρότερη. Για αυτό, αποφασίστηκε να θυσιαστεί χρόνος για να έχουμε καλύτερα αποτελέσματα.
</p>
<p>
Μέσα στο while loop, υλοποιείται ο αλγόριθμος του paper. Αν υπάρχουν μερικά σημεία που είναι άξια αναφοράς, αυτά είναι το διάφορα τρικάκια προκειμένου να αποφύγουμε ελέγχους και εφαρμογές αλλαγών που είναι περιττές. Αρχικά, μια αλλάγη εξετάζεται μονάχα αν η αλυσίδα V δεν έχει τμήματά της μέσα στην ακμή e που εξετάζεται και αν η V δεν έχει τμήματά της και στις γειτονικές της e (e+1,e-1). Επίσης, κάθε αλλαγή που χρησιμοποιείται, μαρκάρεται αλλάζωντας το area της (με -1 αν πρόκειται για μεγιστοποίηση, με convexHullArea αν πρόκειται για ελαχιστοποίηση). Το σκεπτικό είναι ότι, έπειτα από το σορτάρισμα της λίστας (αφού την διατρέξουμε), οι μαρκαρισμένες αλλάγες θα είναι όλες μαζί στην σειρά. Έτσι, μόλις πετύχουμε την πρώτη, μπορούμε απλά να σταματήσουμε να διατρέχουμε την λίστα των αλλαγών, να σκιπαρόυμε τις "άχρηστες" αλλαγές και να συνεχίσουμε στην επόμενη επανάληψη της διαδικασίας βελτίωσης. Τέλος, σε κάθε επανάληψη , ελέχγουμε αν η λιστά αλλαγών είναι κενή (δηλαδή αν όντως βρήκαμε "νόμιμες" και ωφέλιμες αλλαγές) και αν οι αλλαγές που έχουμε στη διάθεση μας είναι όντως "νόμιμες" και "ωφέλιμες" (αυτό γίνεται με τη μεταβλητή improved). Αν καμία από τις παραπάνω συνθήκες δεν ισχύει, τότε θέτουμε το score ίσο με το threshold, έτσι ώστε να βγούμε απο το while loop. 
</p>
<p>
Ειδική μνεία αξίζει να κάνουμε στην λίστα με τις αλλάγες (possibleChanges) και στο τι ακριβώς περιέχει. Συγκεκριμένα, περιέχει structs του τύπου areaChange. Κάθε struct αυτής της μορφής αποτελείται από ένα πεδίο struct changePair που αντιπροσωπεύει την αλλαγή (e,V) και ένα πεδίο area που αντιστοιχεί στο εμβαδό που θα επιφέρει η εφαρμογή της αλλαγής αυτή στο πολύγωνο. Η λίστα possibleChanges είναι σορταρισμένη έτσι ώστε οι καλύτερς αλλαγές, με βάση την βελτιστοποίηση που θέλουμε, να είναι πρώτες.
</p>
</li>
</ul>

<b>Λοιπές Συναρτήσεις:</b><br>
<ul>
<p>Πέρα από τις βασικές συναρτήσεις που περιγράφηκαν πιο πάνω στο local.cpp είναι ορισμένες και κάποιοες βοηθητικές συναρτήσεις.
</p>
<li>
<code> checkThreshold </code> <br>
Η συνάρτηση που ελέγχει αν έχουμε φτάσει ή ξεπεράσει το ζητούμε threshold με βάση τον τύπο της βελτιστοποίησης που ζητείται
</li>
<li>
<code> areaImproves </code> <br>
Η συνάρτηση που ελέγχει αν έχουμε βελτιώσει το εμβαδό με βάση τον τύπο της βελτιστοποίησης που ζητείται
</li>
<li>
<code> findVertexInPoly </code> <br>
Η συνάρτηση που ελέγχει αν μια κορυφή ανήκει στο δοσμένο πολύγωνο
</li>
<li>
<code> findEdgeInPoly </code> <br>
Η συνάρτηση που ελέγχει αν μια ακμή ανήκει στο δοσμένο πολύγωνο
</li>
<li>
<code> compareAlterMin </code> <br>
Η συνάρτηση που συγκρίνει 2 areaChange, για ελαχιστοποίηση
</li>
<li>
<code> compareAlterMax </code> <br>
Η συνάρτηση που συγκρίνει 2 areaChange, για μεγιστοποίηση
</li>
<li>
<code> chainInEdge </code> <br>
Η συνάρτηση που ελέγχει αν έστω και ένα σημείο της αλυσίδας V ανήκει στη δοσμένη ακμή
</li>
<li>
<code> applyChanges </code> <br>
Η συνάρτηση που εφορμόζει τις δωθείσες αλλαγές στο δοσμένο πολύγωνο
</li>
<li>
<code> getVertexIt </code> <br>
Επιστρέφει τον Vertex_Iterator που αντιστοιχεί στην κορυφή. Από το onion.cpp
</li>
<li>
<code> pointInEdge </code> <br>
Η συνάρτηση που ελέγχει αν το δοσμένο σημείο είναι μια από τις κορυφές της ακμής
</li>
<li>
<code> getNextEdge </code> <br>
Συνάρτηση που βρίσκει την επόμενη ακμή μετά το eit και κάνει το eit να δείχνει εκει
</li>
<li>
<code> getPreviousEdge </code> <br>
Συνάρτηση που βρίσκει την προηγούμε ακμή πριν το eit και κάνει το eit να δείχνει εκει
</li>
<li>
<code> getNextIter </code> <br>
Συνάρτηση που βρίσκει την επόμενη κορυφή μετά το veit και κάνει το veit να δείχνει εκει
</li>
<li>
<code> getPreviousIter </code> <br>
Συνάρτηση που βρίσκει την προηγούμε κορυφή πριν το veit και κάνει το veit να δείχνει εκει
</li>
</ul>

<b>Σημειώσεις / Σχεδιαστικές Επιλογές:</b><br>
<ul>
<p> Κατά την υλοποιήση του αλγορίθμου εμφανίστηκε η ανάγκη για την λήψη μερικών σχεδιαστικών επιλογών/αποφάσεων. Αυτές είναι:<br>
</p>
<li> Η δημιουργία του αρχικού πολυγώνου προς βελτιστοποίηση γίνεται εκτός της συνάρτησης optimalPolygon. Το πολύγωνο δίνεται σαν όρισμα κατά την κατασκευή της κλάσσης LocalAlgo. Για την δημιουργία τους παρέχεται η δυνατότητα επιλογής αλγορίθμου από την 1η εργασία κατά την εκτέλεση του προγράμματος από την γραμμή εντολών. Ο χρόνος της δημιουργίας του αρχικού πολυγώνου δεν προσμετράται στον συνολικό
</li>
<li> Στην εργασία έχουμε ακολουθήσει κατά κύριο λόγω τον αλγόριθμο που περιγράφεται στο paper. Παρόλα αυτά, σε κάποια σημεία διαφοροποιούμαστε, συμβουλευόμενοι τις αντίστοιχεσ διαφάνειες. Για παράδειγμα, η λίστα με τις αλλαγές ορίζεται εκτός του εξωτερικού while loop, όπως και στον ψευδοκώδικα των διαφανειών.
</li>
<li> Παρότι δεν αναφέρεται ρητά, υπάρχουν διάφορει έλεγχοι εντος του while loop που εξασφαλίζουν ότι δεν θα καταλήξουμε σε ατέρμονα βρόγχο. Έτσι, σε περίπτωση που σε κάποια επανάληψη η λίστα με τις δυνατές αλλαγές είναι άδεια ή οι αλλαγές που περιέχονται στην λίστα δεν πληρούν τις προϋποθέσεις, βγαίνουμε από το while loop και επιστρέφουμε το πολύγωνο που έχουμε βρει μέχρι εκείνη την στιγμή.
</li>
<li> Σαν score, οπότε συνεπώς και σαν threshold, ορίζουμε την ποσότητα Εμβαδο_Πολυγώνου/Εμβαδο_ΚΠ, όπως και στο paper. Κατά την μεγιστοποίηση του εμβαδού στόχος μας είναι να φτάσουμε αυτή την ποσότητα όσο πιο κοντά στο 1 γίνεται. Αντίστοιχα, κατά την ελαχιστοποίηση στόχος μας είναι να φτάσουμε αυτή την ποσότην όσο πιο κοντά γίνεται στο 0
</li>
Με βάση τη παραπάνω σημείωση, για να έχουμε αποτέλεσματα που βγάζουν κάποιο νόημα πρέπει κατά την εκτέλεση του προγράμματος να δίνεται και η αντίστοιχη τιμή στο threshold. Σε περίπτωση που θέλουμε μεγιστοποίηση (-max στη γραμμή εντολών) οι τιμές του threshold πρέπει να είναι σχετικά κοντά στο 1 (πχ 0.75 ,0.88, 0.95). Αντίστοιχα, σε περίπτωση που θέλουμε ελαχιστοποίηση (-min στη γραμμή εντολών) οι τιμές του threshold πρέπει να είναι σχετικά κοντά στο 0 (πχ 0.20 ,0.16, 0.05).
Το πρόγραμμα θα τρέξει και άμα βάλουμε "λανθασμένη" τιμή (πχ -min με threshold 0.88 ή -max με threshold 0.16), απλά δεν θα επιστρέψει την ζητούμενη βελτιστοποίηση αφού, κατά πάσα πιθανότητα, το αρχικό δοσμένο πολύγωνο θα είναι καλύτερο του threshold (για παράδειγμα στο -max με threshold 0.16, όλα τα αρχικά πολύγωνα συνήθως ξεκινάνε με score πάνω από το 0.5) 
<li> Υπάρχει περίπτωση, για μικρά σημειοσύνολα (πχ με 10 σημεία), το L μην πρέπει να κυμάινεται από 1 μέχρι και 10 αλλά από 1 μέχρι και polygon.size()-1. Σε περίπτωση το L δεν ικανοποιεί αυτή την συνθήκη ή δεν ανήκει στο διάστημα [1,10], ο αλγόριθμος βελτιστοποίησης τυπώνει αντίστοιχο μήνυμα λάθος και επιστρέφει το αρχικό πολύγωνο.
</li>
<li> Παρότι έχει δωθεί η δυνατότητα στον χρήστη να επιλέγει με ποιον αλγόριθμο θα δημιουργεί το αρχικό πολύγωνο προς βελτιστοποίηση, συνίσταται ισχυρά να προτιμάται ο convex_hull (-gen convex_hull).
</li>
<li> Μερικές καλές τιμές για το threshold στην μεγιστοποίηση είναι το 0.88 και το 0.95
</li>
<li> Μερικές καλές τιμές για το threshold στην ελαχιστοποίηση είναι το 0.16 και το 0.06
</li>
</ul>

<b>Αποτελέσματα Εκτελέσεων και Σχολιασμός:</b><br>
<ul>
Τα αποτελέσματα κάποιων ενδεικτικών εκτελέσεων υπάρχουν αναλυτικότερα στον φάκελο docs/ στο αντίστοιχο pdf.
Ένας πρόχειρος σχολιασμός αυτών είναι ο εξής:<br><br>
<p> Αρχικά, πρέπει να σημειώσουμε ότι ο τρόπος με τον οποίον δημιουργείται το αρχικό πολύγωνο επιρεάζει άμεσα και τα αποτελέσματα της βελτιστοποίησης, τόσο από άποψη εμβαδού όσο και από άποψη χρόνου. Από τις 3 διαθέσιμες επιλογές, ο convex_hull αλγόριθμος είναι αυτός που δίνει τα καλύτερα αποτελέσματα. Μπορεί να μην είναι ο πιο γρήγορος για την δημιουργία του πολυγώνου αλλά το πολύγωνο που θα προκύψει είναι πολύ πιο κοντά στο βέλτιστο απ'ότι τα πολυγώνα που θα προκύψουν είτε από τον incremental είτε από τον onion. Για παράδειγμα, αν και ο onion φαίνεται σαν μια ελκυστική επιλογή για σημειοσύνολα μεγάλου μεγέθους (200+ σημεια) στην πραγματικότητα πρόκειται για μια μάλλον κακή επιλογή. Αυτό συμβαίνει γιατί το πολύγωνο που προκύπτει δεν έχει δημιουργηθεί με κάποια άπληστη στρατηγική ως προς το εμβαδόν, με αποτέλεσμα να απέχει αρκετά από το βέλτιστο (άρα και το score του να απέχει από threshold με συνέπεια πιο πολλές επαναλήψεις), γεγονός που οδηγεί σε περισσότερες αλλαγές (άρα και μεγαλύτερη λίστα αλλαγών με συνέπεια περισσότερους ελέγχους). Οπότε, ό,τι γλυτώνουμε κατά την δημιοργία του πολυγώνου το "πληρώνουμε" κατά την βελτιστοποίησή του. 
</p>
<p> 'Επειτα, αξίζει να αναφερθούμε και στο μήκος της αλυσίδας V, το L. Είναι προφανές πως όσο μεγαλύτερο μήκος έχει η αλυσίδα τόσο πιο αργή θα είναι η βελτιστοποίηση μιας και η λίστα αλλαγών θα περιέχει περισσότερες αλλαγές. Παρόλα αυτά, το ίδιο δεν μπορεί να ειπωθεί και για το εμβαδό. Μεγαλύτερη αλυσίδα (για το ίδιο πάντα σημειοσύνολο και threshold) δεν εγγυάται και μεγλύτερο εμβαδό. Το φαινόμενο αυτό παρατηρείται κατά κύριο λόγο στο πιο μικρά σημειοσύνολα (20,30 στοιχείων). Όσο μεγαλώνουν τα σύνολα (και άρα όσο πληθαίνουν και οι δυνατές επιλογές που έχουμε στην λίστα αλλαγών), τα αποτελέσματα που παίρνουμε πλησιάζουν τα αναμενόμενα, με το εμβαδό να μεγαλώνει όσο μεγαλώνει και το L.
</p>
<p> Ειδική αναφορά πρέπει να γίνει και στις τιμές του threshold, μιας και είναι ένας από τους πιο σημαντικούς παράγοντες που επιρεάζουν το χρόνο και το εμβαδό. Ήδη έχει αναφερθεί πιο πάνω πως άμα θέλουμε μεγιστοποίηση πρέπει να δίνουμε στο threshold τιμές κοντά στο 1 και στην περίπτωση που θέλουμε ελαχιστοποίηση τιμές κοντά στο 0. Όπως είναι προφανές, όσο "καλύτερες" τιμές δώσουμε με βάση την βελτιστοποίηση που θέλουμε (-min ή -max) τόσο "καλύτερο" πολύγωνο θα πάρουμε. Αυτό βέβαια θα έρθει με ένα τίμημα αφού θα έχουμε και μεγαλύτερους χρόνους. 
</p>
<p> Τέλος, αναφορικά με το πλήθος των σημειών είναι πασιφανές πως όσο περισσότερα σημεία υπάρχουν τόσο πιο αργή θα είναι η εκτέλεση του προγράμματός μας. Επίσης, σε περίπτωση που το αρχικό πολύγωνο έχει δημιουργηθεί με τον convex_hull, καλό είναι το threshold να υπερβαίνει το 0.9 σε περίπτωση -max και να είναι λιγότερο από 0.05 σε περίπτωση -min, μιας και ο αλγόριθμος convex_hull φαίνεται να δημιουργεί "καλά" πολύγωνα για μεγάλο πλήθος σημείων.
</p>
</ul>
<br>

## Simulated Annealing
<p>
<b>Συναρτήσεις:</b> <br>
<ul>
<li><b>optimalPolygon</b>: Επιστρέφει την βελτιστοποιημένη λύση που επιστρέφει ο αλγόριθμος Simulated Annealing. Ανάλογα με τις παραμέτρους που δόθηκαν κατά την εκτέλεση του προγράμμτος, καλείται μία εκ των <b>localAnnealing</b>,<b>globalAnnealing</b> και <b>ubdivisionAnnealing</b></li>
<li><b>localAnnealing, globalAnnealing</b>: Υλοποιούν τον αλγόριθμο που περιγράφεται στις διαφάνειες του μαθήματος. Συγκεκριμένα: <br><ol>
<li>Βρίσκουμε έκγυρη μετάβαση των κορυφών</li>
<li>Ελέγχουμε αν η κατάσταση είναι αποδεκτή, βάσει της διαφοράς της τελικής ενέργειας από την αρχική, και (αν η διαφορά δεν είναι θετική) του Metropolis criterion</li>
<li>Ανάλογα με τον προηγούμενο έλεγχο, διατηρούμε ή αναστρέφουμε την μετάβαση του 1ου βήματος</li>
<li>Εφόσον είναι θετική η θερμοκρασία, επιστρέφουμε στο βήμα 1</li>
</ol><i>η subdivisionAnnealing δεν δουλεύει.</i></li>
<li><b>localAnnealing</b>: Για τον έλεγχο εγκυρότητας χρησιμοποιεί την validityLocal</li>
<li><b>globalAnnealing</b>: Για τον έλεγχο εγκυρότητας χρησιμοποιεί την validity global</li>
<li><b>validityLocal</b>: Ελέγχει αν οι νέες ακμές τέμνονται μεταξύ τους, ή αν τέμνουν κάποια άλλη ακμή του πολυγώνου. Για τον δεύτερο έλεγχο αξιοποιούν το kd-tree που έχει αρχικοποιηθεί από την <b>localAnnealing</b> μέσω της <b>initializeTree</b>. Για την αναζήτηση των σημείων στο χώρο που μας ενδιαφέρει δη, παίρνουμε το Fuzzy_iso_box που περιγράφει τον χώρο μέσω της <b>getQueryBox</b> και αποθηκεύουμε το αποτέλεσμα της αναζήτησης σε ένα vector με σημεία μέσω της <b>getQueryResult</b>. Επιστρέφει true αν είναι έγκυρη η νέα κατάσταση, αλλιώς false</li>
<li><b>validityGlobal</b>: Ελέγχει αν οι νέες ακμές τέμνονται μεταξύ τους, ή αν τέμνουν κάποια άλλη ακμή του πολυγώνου με εξαντλητική αναζήτηση.</li>
<li><b>initializeTree</b>: Εισάγει όλα τα σημεία του πολυγώνου <b>poly</b> στο kd-tree <b>tree</b>. Τα <b>poly</b> και <b>tree</b> δίνονται ως ορίσματα στην συνάρτηση.</li>
<li><b>getQueryBox</b>: Επιστρέφει ένα fuzzy_iso_box με διαστάσεις [xmin, ymin][xmax, ymax], όπου xmin/xmax και ymin/ymax ή ελάχιστη/μέγιστη τετμημένη και τεταγμένη αντίστοιχα των 4 σημείων που δίνονται ως ορίσματα.</li>
<li><b>getQueryResult</b>: Αποθηκεύει στο vector <b>result</b> το αποτέλεσμα της αναζήτησης στο kd-tree <b>tree</b> με βάσει το fuzzy_iso_box <b>query</b>. Τα <b>result</b>, <b>query</b> και <b>tree</b> δίνονται σαν ορίσματα στην συνάρτηση.</li>
<li><b>getEnergy</b>: επιστρέφει την ενέργεια της τρέχουσας κατάστασης του πολυγώνου, βάσει του τύπου που αντιστοιχεί στην βελτιστοποίηση που θέλουμε (ελαχιστοποίηση ή μεγιστοποίηση) καλώντας μία εκ των minimizationEnergy και maximizationEnergy.</li>
<li><b>minimizationEnergy</b>: Επιστρέφει την τιμή του τύπου της ενέργειας για ελαχιστοποιηση όπως αυτός δίνεται στις διαφάνειες του μαθήματος</li>
<li><b>maximizationEnergy</b>: Επιστρέφει την τιμή του τύπου της ενέργειας για μεγιστοποίηση όπως αυτός δίνεται στις διαφάνειες του μαθήματος</li>
<li><b>moveVertex</b>: Μεταφέρει την κορυφή που βρίσκεται στην θέση <b>from</b> πριν την κορυφή που βρίσκεται στην θέση <b>to</b>. Οι δείκτες σε κορυφές <b>from</b> και <b>to</b> δίνονται ως ορίσματα στην συνάρτηση.</li>
</ul>
</p>
<p>
<b>Αποτελέσματα και σχολιασμός</b>: <br>
Δεν δείχνουμε ακόμη αποτελέσματα, άρα και σχολιασμό αυτών, καθώς δεν γίνεται σωστά ο έλεγχος εγκυρότητας, με αποτέλεσμα τα παραγόμενα πολύγωνα να μην είναι αποδεκτά.<br>
</p>
<br>

## Ant Colony
<b>Δομή κωδικα/λειτουργιες:</b>

Ο αλγόριθμος είναι μια τροποποίηση του incremental algorithm από την πρώτη εργασία σε συνδυασμό με τον ant colony algorithm.

<b>Γενική ιδέα:</b> Για την απόπειρα εύρεσης βέλτιστου εμβαδού δημιουργείται ένας γραφος στον οποίο θα κινούνται τα μυρμήγκια που έχει σαν κόμβους πολύγωνα. Αρχικά δημιουργούνται όλα τα τρίγωνα που γίνεται να υπάρχουν στο σημειοσύνολο. Αυτό γίνεται με την συνάρτηση generate3 η οποία επιλεγεί 3 σημεία και βλέπει εάν δεν υπάρχει κάποιο άλλο σημείο που να είναι εσωτερικό στο τρίγωνο. Εάν αυτό ισχύει το τρίγωνο είναι έγκυρο και μπαίνει στην λίστα των πιθανών τριγωνων/εντασσεται στον γραφο. Μέτα για κάθε μυρμήγκι επιλέγεται ένα αρχικό τρίγωνο με βάση το είδος του αλγορίθμου (εάν είναι μεγιστοποίηση τότε διαλέγει με βάση το ποσοστό του εμβαδού του συγκεκριμένου τρίγωνου με το μέσο εμβαδό των υπολοίπων, αντίστοιχα για ελαχιστοποίηση). Έπειτα αφού διαλέξει τρίγωνο φτιάχνει όλα τα δυνατά τετράγωνα που ξεκινάνε από το τρίγωνο. Αυτό γίνεται με την συνάρτηση GenerateX. Προσθέτει αυτά τα τετράγωνα στο γραφο και σε κάποιες δομές. Συνεχίζει μέχρι να τελειώσει το σημειοσύνολο και έπειτα ξεκινάει νέο μυρμήγκι. Όταν τελειώσουν όλα τα μυρμηγκιά τότε βρίσκεται το μεγιστο/ελαχιστο εμβαδόν μέχρι τώρα και αποθηκεύονται στην δομή paths τα μονοπάτια των μυρμηγκιών. Καλείται η UpdtateTrails η οποία εάν βρει κόμβο στον γραφο που το μυρμήγκι χρησιμοποίησε τότε ανανεώνει κατάλληλα την φερομονη. Έπειτα “εξασθενειται” η φερομονη από κάθε ακμή και συνεχίζει στον επόμενο κύκλο. Όταν τελειώσουν όλοι οι κύκλοι επιστρέφει το μεγιστο/ελαχιστο εμβαδόν που βρήκε.

<b>Δομές: Γενικό: </b> Τα πολύγωνα αντιστιχούνται με έναν αριθμό για να μην χρειάζεται να κρατάμε παντού την δομή τους.
</b>
<li><b> polymap: </b> Ένα map για να μπορούμε να φτιάχνουμε τα πολύγωνα με βάση τον αριθμό τους. </li></b>

<li><b> map: </b> Ένα map για να μπορούμε να ξέρουμε ποιο πολύγωνο έχει φτιαχτεί μέχρι τώρα. </li></b>

<li><b> table1: </b> O βασικός γραφος. </li></b>

<li><b> tables: </b> Μια δομή η οποία περιεχέι τον πάτερα και τα παιδιά ενός κόμβου. </li></b>

<li><b> enumvals: </b> Ένας πίνακας που περιεχεί τον αριθμό του πολύγωνου.
    </li></b>
 <br/><br/>
<b> Παρατηρήσεις:</b> 
    Ο αλγόριθμος είναι αρκετά αργός, που είναι λογικό, επειδή είναι σε έναν βαθμό παρόμοιος με brute force algorithm. Φτιάχνει κάθε φορά όλα τα δυνατά πολύγωνα από την συγγεκριμενη θέση, εφόσον αυτά δεν έχουν φτιαχτεί ήδη, που τότε τα συνδέει στο γραφο.<b>Η κυρία αναφορά βρίσκεται στο φάκελο docs με εικόνες και σχολιασμούς.</b> Περιληπτικά μπορούμε να δούμε ότι ο αλγόριθμος όσο μεγαλώνει το β τόσο πιο "μικρά" είναι τα εμβαδά, όσο μεγαλώνει το Λ γίνεται πιο χρονοβόρο αλλά και ακριβές το αποτέλεσμα.Γίνανε πειράματα με 15/20/50 σημεία για διαφορετικά α,β,Λ και ρ ,αλλά αναφέρουμε μονο τα πιο σημαντικά.

<br>
